{-# LANGUAGE OverloadedStrings, QuasiQuotes #-}
module Main where

-- generated by cabal at build time
import Paths_tubular (version)

-- main libraries
import Snap
import Snap.Util.FileServe
import Text.Cassius
import Text.Hamlet
-- import Dhall
import Options.Applicative
import System.Posix.Signals

-- supporting libraries
import System.Directory
import Text.Blaze.Html.Renderer.Text

-- base
import Control.Concurrent
import Control.Exception
import Control.Monad
import Data.Monoid

-- internal
import Daemon
import Experiments

data CliArgs = CliArgs {
  configFile :: FilePath,
  pidFile :: FilePath,
  daemonize :: Bool,
  processAction :: String
}

parseCliArgs :: Parser CliArgs
parseCliArgs = CliArgs <$>
  strOption (
    long "config" <>
    metavar "path" <>
    help "Path to config file" <>
    showDefault <>
    value "/etc/tubulard/tubulard.cf") <*>
  strOption (
    long "pid-file" <>
    metavar "path" <>
    help "Path to PID file" <>
    showDefault <>
    value "/var/run/tubulard.pid") <*>
  switch (
    long "daemonize" <>
    help "Run in the background") <*>
  argument str (
    metavar "action" <>
    help "Whether to start or stop the daemon" <>
    showDefault <>
    value "start")

runCliParser :: IO CliArgs
runCliParser = execParser (info (parseCliArgs <**> helper) (fullDesc <> progDesc "A totally tubular firewall frontend" <> header "Tubular"))

main :: IO ()
main = do
  -- get command-line options
  cliArgs <- runCliParser
  -- get config file options
  case processAction cliArgs of
    "start" -> do
      -- daemonize
      case daemonize cliArgs of
        True -> do
          runDaemon (pidFile cliArgs) "tubulard" $ do
            -- print debug info
            putStrLn ("Tubular version: (" <> show version <> ")")
            -- serve http
            let config = defaultConfig
            httpServe config snapMain
        False -> do
          -- print debug info
          putStrLn ("Tubular version: (" <> show version <> ")")
          -- serve http
          let config = defaultConfig
          httpServe config snapMain
    "stop" -> do
      let pidFilePath = pidFile cliArgs
      fileExists <- doesPathExist pidFilePath
      case fileExists of
        -- no other instances running
        False -> error (pidFilePath <> " not found")
        True -> do
          -- see if the pid file references an active process
          pidstr <- readFile pidFilePath
          pid <- readIO pidstr
          guard (pid > 1)
          signalled <- catch (signalProcess keyboardTermination pid >> pure True) (\(SomeException _) -> pure False)
          case signalled of
            False -> error ("Process " <> pidstr <> " in " <> pidFilePath <> " not found")
            True -> do
              -- confirm it's gone
              threadDelay (1 * 1000 * 1000)
              signalled' <- catch (signalProcess nullSignal pid >> pure True) (\(SomeException _) -> pure False)
              case signalled' of
                True -> error ("Process " <> pidstr <> " did not stop")
                False -> pure ()
    s -> error ("Unrecognized action " <> s)
  pure ()

snapMain :: Snap ()
snapMain = do
  route [
    ("/", spage indexdoc),
    ("/css/bootstrap.min.css", serveFile "/usr/local/share/tubular/bootstrap.min.css"),
    ("/css/formtest.css", writeLazyText $ renderCss formtestcss),
    -- ("/js", spage [shamlet|blahblah|]),
    ("/formtest", spage formtestdoc),
    ("/:ignore", spage [shamlet|404|])
    ]

-- for shamlet
spage :: Html -> Snap ()
spage body = writeLazyText (renderHtml [shamlet|
  $doctype 5
  <html>
    <head>
      <meta charset="utf-8">
      <link rel="stylesheet" href="/css/bootstrap.min.css">
      <link rel="stylesheet" href="/css/formtest.css">
    <body>
      ^{body}
|])

indexdoc :: Html
indexdoc = [shamlet|
|]

