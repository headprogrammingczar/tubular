{-# LANGUAGE OverloadedStrings #-}
module Main where

-- generated by cabal at build time
import Paths_tubular (version)

-- main libraries
import Snap
-- import Dhall
import Options.Applicative
import System.Posix.Syslog
import System.Posix.IO
import System.Posix.Process
import System.Posix.Types (Fd)

-- supporting libraries
import Foreign.C.String

-- base
import Control.Concurrent
import Control.Monad
import Data.Monoid
import System.IO

data CliArgs = CliArgs {
  configFile :: FilePath,
  pidFile :: FilePath,
  daemonize :: Bool
}

parseCliArgs :: Parser CliArgs
parseCliArgs = CliArgs <$>
  strOption (
    long "config" <>
    metavar "path" <>
    help "Path to config file" <>
    showDefault <>
    value "/etc/tubulard/tubulard.cf") <*>
  strOption (
    long "pid-file" <>
    metavar "path" <>
    help "Path to PID file" <>
    showDefault <>
    value "/var/run/tubulard.pid") <*>
  switch (
    long "daemonize" <>
    help "Run in the background")

runCliParser :: IO CliArgs
runCliParser = execParser (info (parseCliArgs <**> helper) (fullDesc <> progDesc "A totally tubular firewall frontend" <> header "Tubular"))

main :: IO ()
main = do
  -- get command-line options
  cliArgs <- runCliParser
  -- get config file options
  -- daemonize
  runDaemon cliArgs $ do
    -- print debug info
    putStrLn ("Tubular version: (" ++ show version ++ ")")
    -- serve http
    let config = defaultConfig
    httpServe config snapMain
  pure ()

runDaemon :: CliArgs -> IO () -> IO ()
runDaemon _config daemonAction = do
  -- check if running
  -- first fork
  void $ forkProcess $ do
    -- setsid
    void createSession
    -- second fork
    void $ forkProcess $ do
      -- umask
      -- handle signals
      -- detach stdin
      detachFd stdInput
      -- create pid file
      -- set up syslog
      withSyslog "tubulard" [LogPID, ImmediateOpen] Daemon $ do
        logFd "stdout" stdOutput
        logFd "stderr" stdError
        -- run service
        daemonAction

-- redirects an Fd to syslog
-- the Fd is consumed from a forkIO thread
logFd :: String -> Fd -> IO ()
logFd label fd = do
  (r, w) <- createPipe
  void (dupTo w fd)
  void $ forkIO $ do
    h <- fdToHandle r
    forever $ do
      line <- hGetLine h
      syslog' Warning label line

syslog' :: Priority -> String -> String -> IO ()
syslog' p label s = withCStringLen (label <> ": " <> s) $ syslog Nothing p

detachFd :: Fd -> IO ()
detachFd fd = do
  devNull <- openFd "/dev/null" ReadWrite Nothing defaultFileFlags
  void (dupTo devNull fd)
  closeFd devNull

snapMain :: Snap ()
snapMain = do
  route [
    ("", writeText "test")
    ]
