{-# LANGUAGE OverloadedStrings #-}
module Main where

-- generated by cabal at build time
import Paths_tubular (version)

-- main libraries
import Snap
-- import Dhall
import Options.Applicative
import System.Posix.Syslog
import System.Posix.Files
import System.Posix.IO
import System.Posix.Process
import System.Posix.Signals
import System.Posix.Types (Fd)

-- supporting libraries
import Foreign.C.String
import System.Directory

-- base
import Control.Concurrent
import Control.Exception
import Control.Monad
import Data.Monoid
import System.Exit
import System.IO

data CliArgs = CliArgs {
  configFile :: FilePath,
  pidFile :: FilePath,
  daemonize :: Bool,
  processAction :: String
}

parseCliArgs :: Parser CliArgs
parseCliArgs = CliArgs <$>
  strOption (
    long "config" <>
    metavar "path" <>
    help "Path to config file" <>
    showDefault <>
    value "/etc/tubulard/tubulard.cf") <*>
  strOption (
    long "pid-file" <>
    metavar "path" <>
    help "Path to PID file" <>
    showDefault <>
    value "/var/run/tubulard.pid") <*>
  switch (
    long "daemonize" <>
    help "Run in the background") <*>
  argument str (
    metavar "action" <>
    help "Whether to start or stop the daemon" <>
    showDefault <>
    value "start")

runCliParser :: IO CliArgs
runCliParser = execParser (info (parseCliArgs <**> helper) (fullDesc <> progDesc "A totally tubular firewall frontend" <> header "Tubular"))

main :: IO ()
main = do
  -- get command-line options
  cliArgs <- runCliParser
  -- get config file options
  case processAction cliArgs of
    "start" -> do
      -- daemonize
      case daemonize cliArgs of
        True -> do
          runDaemon cliArgs $ do
            -- print debug info
            putStrLn ("Tubular version: (" <> show version <> ")")
            -- serve http
            let config = defaultConfig
            httpServe config snapMain
        False -> do
          -- print debug info
          putStrLn ("Tubular version: (" <> show version <> ")")
          -- serve http
          let config = defaultConfig
          httpServe config snapMain
    "stop" -> do
      let pidFilePath = pidFile cliArgs
      fileExists <- doesPathExist pidFilePath
      case fileExists of
        -- no other instances running
        False -> error (pidFilePath <> " not found")
        True -> do
          -- see if the pid file references an active process
          pidstr <- readFile pidFilePath
          pid <- readIO pidstr
          guard (pid > 1)
          signalled <- catch (signalProcess keyboardTermination pid >> pure True) (\(SomeException _) -> pure False)
          case signalled of
            False -> error ("Process " <> pidstr <> " in " <> pidFilePath <> " not found")
            True -> do
              -- confirm it's gone
              threadDelay (1 * 1000 * 1000)
              signalled' <- catch (signalProcess nullSignal pid >> pure True) (\(SomeException _) -> pure False)
              case signalled' of
                True -> error ("Process " <> pidstr <> " did not stop")
                False -> pure ()
    s -> error ("Unrecognized action " <> s)
  pure ()

runDaemon :: CliArgs -> IO () -> IO ()
runDaemon config daemonAction = do
  -- check if running
  checkPid (pidFile config)
  -- first fork
  void $ forkProcess $ do
    -- setsid
    void createSession
    -- second fork
    void $ forkProcess $ do
      -- umask - prevent files from being group or world usable
      void $ setFileCreationMask (unionFileModes groupModes otherModes)
      -- handle signals - use CatchOnce because if it doesn't exit the first time, something is wrong
      mainThreadId <- myThreadId
      void $ installHandler keyboardTermination (CatchOnce (gracefulExit mainThreadId (pidFile config))) Nothing
      void $ installHandler softwareTermination (CatchOnce (gracefulExit mainThreadId (pidFile config))) Nothing
      -- detach stdin
      detachFd stdInput
      -- create pid file
      pid <- getProcessID
      writeFile (pidFile config) (show pid)
      -- set up syslog
      withSyslog "tubulard" [LogPID, ImmediateOpen] Daemon $ do
        hSetBuffering stdout LineBuffering
        hSetBuffering stderr LineBuffering
        logFd "stdout" stdOutput
        logFd "stderr" stdError
        -- run service
        daemonAction

-- return if program can continue
-- otherwise exit
checkPid :: FilePath -> IO ()
checkPid pidFilePath = do
  fileExists <- doesPathExist pidFilePath
  case fileExists of
    -- no other instances running
    False -> pure ()
    True -> do
      -- see if the pid file references an active process
      pidstr <- readFile pidFilePath
      pid <- readIO pidstr
      guard (pid > 1)
      running <- catch (signalProcess nullSignal pid >> pure True) (\(SomeException _) -> pure False)
      case running of
        False -> pure ()
        True -> error ("Already running in pid "++pidstr)

gracefulExit :: ThreadId -> FilePath -> IO ()
gracefulExit mainThreadId pidFilePath = do
  removeFile pidFilePath
  -- signal handlers run in a forkIO thread
  -- but only the main thread can exit the program
  throwTo mainThreadId ExitSuccess

-- redirects an Fd to syslog
-- the Fd is consumed from a forkIO thread
logFd :: String -> Fd -> IO ()
logFd label fd = do
  (r, w) <- createPipe
  rh <- fdToHandle r
  void (dupTo w fd)
  void $ forkIO $ do
    forever $ do
      line <- hGetLine rh
      syslog' Warning label line

syslog' :: Priority -> String -> String -> IO ()
syslog' p label s = withCStringLen (label <> ": " <> s) $ syslog Nothing p

detachFd :: Fd -> IO ()
detachFd fd = do
  devNull <- openFd "/dev/null" ReadWrite Nothing defaultFileFlags
  void (dupTo devNull fd)
  closeFd devNull

snapMain :: Snap ()
snapMain = do
  route [
    ("", writeText "test")
    ]
